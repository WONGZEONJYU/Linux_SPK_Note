# 十一 ｜十二、信号发送与处理

## (一) 信号的概念及分类

### 1. 问题

>❓按下 ctrl+c 后 , 命令行的前台进程会被终止 , why?

### 2. 什么是信号

>- 信号是一种 **$\color{red}{"软件中断"}$** , 用来处理异步事件
>   - 内核发送信号到某个进程 , 通知进程事件的发生
>   - 事件可能来自硬件 , 可能来自用户输入 , 可能来自程序自身错误 (如除零错误等)
>
> - 信号是一种类型的 $\color{red}{进程间通信方式}$ ( **$\color{red}{一个进程向另一个进程发送信号}$** )
>   - A进程发生事件T , 向B进程发送信号 , B进程执行动作响应事件
>   - 进程可以对接收到的 $\color{red}{不同信号}$ 进行 $\color{red}{不同动作响应}$ (信号 , 处理)
>

### 3. 信号的分类

>- 硬件异常
>   - 内核检测到硬件错误 , 发送相应信号给相关进程
>- 终端信号 (用户交互信号)
>   - 在终端输入“特殊字符”等价于向前台进程组发送相应的信号
>- 软件信号
>   - 在软件层面 (进程代码中) 触发的信号 (发送给自身或其它进程)
>

#### (1) 硬件异常信号

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724134116113.png" alt="image-20230724134116113" />

(2) 终端相关信号

>- `SIGINT` ( `ctrl + c` )
>   - 程序终止信号，用于通知前台进程组终止进程
>- `SIGQUIT` ( `ctrl + \` )
>   - 与`SIGINT`类似，进程收到该信号退出时可产生 coredump 文件
>- `SIGTSTP`( `ctrl + z` )
>   - 停止进程的运行 , 进程收到该信号后可以选择处理和忽略
>   - 进程收到该信号后停止运行 (状态发生转换) , 后续可恢复运行状态

#### (3) 软件相关信号

>- 子进程退出 : 父进程收到`SIGCHLD`信号
>- 父进程退出 : 子进程可能收到信号 ( 什么信号? )
>- 定时器到期 : `alarm()` , `ualarm()` , `timer_create()` , ……
>- 主动发送信号 : `kill()` , `raise()` , ……
>- ……

### 4. 内核与信号

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724134602656.png" alt="image-20230724134602656" />

### 5. System V  vs  BSD

>- System V：也被称为 AT&T SystemV，是Unix操作系统众多版本中的一支
>- BSD：加州大学伯克利分校开创，Unix衍生系统，代表由此派生出的各种套件组合
>
>```
>📖 Linux之所以被称为类Unix操作系统,部分原因就是Linux的操作风格是介于上述二者之间,且不同厂商为了照顾不同的用户,其发行版本的操作风格存在差异
>```
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724134745523.png" alt="image-20230724134745523" />

## (二) 信号发送与处理

### 1. 信号处理

#### (1) 信号的默认处理

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724134843703.png" alt="image-20230724134843703" />

#### (2) 自定义信号处理

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724134902389.png" alt="image-20230724134902389" />
>
>```c++
>#include <sys/types.h>
>#include <signal.h>
>typedef void(*sighandler_t)(int);
>sighandler_t signal(int signum, sighandler_t handler);
>sighandler_t sysv_signal(int signum, sighandler_t handler);
>sighandler_t bsd_signal(int signum, sighandler_t handler);
>```

#### (3) 信号处理示例

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724134954717.png" alt="image-20230724134954717" />

### 2. 信号发送

#### (1) 自定义信号发送

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724135036046.png" alt="image-20230724135036046" />
>
>```c++
>#include <sys/types.h>
>#include <signal.h>
>int kill(pid_t pid, int sig); 
>int raise(int sig); // 信号处理完毕后返回 (信号处理函数的每一段代码执行完毕之后才返回)
>```
>
>```
>📖
>标准信号是Unix系统中的信号,编号范围从1到31
>实时信号是Linux独有的信号,编号范围从32到64
>```
>
>- `kill(...)` 和 `raise(...)` 是用来发送信号的 : 
>   - `raise(...)` 把信号发送给 **(进程)** 自身
>   - `kill(...)` 把信号发送给 **进程** 或 **进程组**
>    - `pid > 0` , 将信号传给进程识别码为pid 的进程
>    - `pid == 0` , 将信号传给和目前进程相同进程组的所有进程 ($\color{red}{当前进程组下的所有进程}$ 都会收到信号)
>    - `pid == -1` , 将信号 **$\color{red}{广播}$** 传送给系统内所有的进程
>    - `pid < 0` , 将信号传给 进程组识别码 为 pid绝对值 的所有进程

#### (2) 信号发送示例

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724135456467.png" alt="image-20230724135456467" />

#### (3) 编程实验 : 信号发送与处理

>[信号发送与处理main.cpp参考代码](https://github.com/WONGZEONJYU/Linux_System_Program/blob/main/10.Signal/11/main.cpp)
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724135548971.png" alt="image-20230724135548971" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724135554672.png" alt="image-20230724135554672" />
>
>[main.cpp test.cpp参考代码](https://github.com/WONGZEONJYU/Linux_System_Program/tree/main/10.Signal/11)
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724135752977.png" alt="image-20230724135752977" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724135800125.png" alt="image-20230724135800125" />

### (三) 信号处理三大特性

#### 1. 问题

>❓三种注册信号与处理函数的方法有什么区别?

#### 2. 信号的OneShot 性

>- System V风格的signal函数 , 注册的 $\color{red}{信号处理是}$ **$\color{red}{一次性的}$**
>   - 进程收到信号后 , 调用由signal注册的处理函数
>   - 处理函数一旦执行之后 , 进程通过默认的方式处理后续相同信号
>- 如果想要重复触发 , 那么必须再次调用 sys_v风格 的`signal(...)` (`sysv_signal(...)`) 注册处理函数
>- BSD风格的signal函数不存在 OneShot , 能够自动反复触发处理函数的调用
>- 默认的signal函数和BSD风格的signal函数一致
>

#### 3. 信号的自身屏蔽特性

>- 在信号处理函数执行期间 (还未处理结束) , $\color{red}{很可能再次收到当前信号 (相同信号)}$
>   - 即 : 处理 A 信号的时候 , 再次收到 A 信号
>- 对于 System V 风格的 signal 函数 , $\color{red}{会引起信号处理函数的重入}$
>   - 即 : 调用处理函数的过程中 , 再次收到同个信号触发信号处理函数的调用
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724140701032.png" alt="image-20230724140701032" />
>
>```
>❓思考:BSD风格的signal函数,处理A信号期间,如果收到B信号会发生什么?
>```

#### 4.系统调用重启特性

>- 系统调用期间 , 可能收到信号 , $\color{red}{此时进程 必须 从系统调用中 返回}$ 
>- 对于执行时间较长的系统调用 ( `write()` / `read()` ) , 被信号中断的可能性很大
>   - 如果希望信号处理之后 , 被中断的系统调用能够重启 , 则 : 
>     - 可以通过条件 `errno == EINTR` 判断手动重启系统调用
>
>- 系统调用重启示例代码 ( `wait()` ) :
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724141935773.png" alt="image-20230724141935773" />
>
>- 系统调用重启特性 : 
>   - System V 风格的 signal() 函数 : ( 手工重启 )
>     - 系统调用被信号中断后 , 直接返回 -1 , 并且 `errno == EINTR`
>
>   - BSD 风格的 signal() 函数 : ( 自动重启 )
>     - 系统调用被中断 , 内核在信号处理函数结束后 , 自动重启系统调用
>





