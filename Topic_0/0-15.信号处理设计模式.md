# 十五、信号处理设计模式

## (一) Linux应用程序安全性讨论

### 1. 问题

>❓如何编写信号安全的应用程序? ? ?

### 2. 不同场景

#### (1) 场景一 : 不需要处理信号

>- 应用程序实现单一功能 , 不需要关注信号
>- 如 : 数据处理程序 , 文件加密程序、科学计算程序

#### (2) 场景二 : 需要处理信号

>- 应用程序长时间运行 , 需要关注信号 , 并及时处理
>- 如 : 服务端程序 , 上位机程序
>

## (二) 场景一 : 不需要信号处理 (单一功能应用程序)

>```
>📖 在代码层面,直接阻塞所有可能的信号(本质上就是信号始终处于未决状态,无法递达进程)
>```
>
><img src="./assets/image-20230801145158685.png" alt="image-20230801145158685" />
>
>- 编程实验 : 不需要处理信号
>
>[编程实验：不需要处理信号](https://github.com/WONGZEONJYU/Linux_System_Program/blob/main/10.Signal/15/0_no_need_signal/main.cpp)
>
><img src="./assets/image-20230801145207886.png" alt="image-20230801145207886" />
>
><img src="./assets/image-20230801145215027.png" alt="image-20230801145215027" />

## (三) 场景二 : 需要处理信号 (长时间运行的应用)

>- **$\color{red}{同步方案}$**
>   - 通过 **$\color{red}{标记}$** 同步处理信号 , 整个应用中 **$\color{red}{只有一个执行流( 交替执行 )}$**
>- **$\color{red}{异步方案}$**
>   - 专用任务处理 , 应用中存在 **$\color{red}{多个执行流 (多线程应用)}$**
>   - 设置 **$\color{red}{专用于信号处理的任务}$** , 其它任务忽略信号 , 专注功能实现

### 1.同步解决方案 (单任务)

> - 信号处理逻辑与程序逻辑位于同一个上下文
>   - 即：信号处理函数与主函数不存在资源竞争关系

#### (1) 方案设计一

>1. 将任务分解为 **$\color{red}{子任务}$** (每个任务可对应一个函数)
>2. 信号递达时 , 信号处理函数中 $\color{red}{仅}$ **$\color{red}{标记}$** $\color{red}{递达状态}$
>3. $\color{red}{子任务处理结束后 , 真正执行信号处理}$
>
><img src="./assets/image-20230801145224046.png" alt="image-20230801145224046" />

##### ① 同步方案示例一

><img src="./assets/image-20230801145230004.png" alt="image-20230801145230004" />

##### ② 编程实验

>[同步方案一参考代码](https://github.com/WONGZEONJYU/Linux_System_Program/tree/main/10.Signal/15/1_Synchronize)

###### a. 对于不可靠信号

><img src="./assets/image-20230801145238362.png" alt="image-20230801145238362" />
>
><img src="./assets/image-20230801145245714.png" alt="image-20230801145245714" />

###### b. 对于可靠信号存在问题

><img src="./assets/image-20230801145251952.png" alt="image-20230801145251952" />
>
><img src="./assets/image-20230801145258893.png" alt="image-20230801145258893" />
>
><img src="./assets/image-20230801145305278.png" alt="image-20230801145305278" />

##### ③ 存在的问题

>- 由于给每个信号唯一的标记位置 , 因此 , **$\color{red}{所有信号转变为不可靠信号}$** , 并且仅保留最近递达的信号信息
>- 可能改进方案 : 
>   - 标记位置设计为链表 , 信号递达后在对应位置的链表处增加结点保留信号信息 ( 增加结点涉及到 `malloc()` , 不安全 )
>

#### (2) 方案设计二

> - 将任务分解为子任务 (每个任务可对应一个函数)
> - 创建 **$\color{red}{信号文件描述符}$** , 并阻塞所有信号 (可靠信号递达前位于内核队列)
>   - 意义 : 化被动为主动 , 原先任务的执行流在收到信号后被动中断。现在主动去检查是否有信号 , 如果有信号 , 将信号取出来处理 , 此时就需要文件描述符。
> - 子任务处理结束后 , 通过 `select(...)` $\color{red}{机制}$ 判断是否有信号需要处理
>   - `true` : 处理信号 , `false` : 等待超时

##### ① 系统关键函数

><img src="./assets/image-20230801145313868.png" alt="image-20230801145313868" />
>
>- 使用 `signalfd()` 处理信号
>  - 先屏蔽所有信号(无法递达进程) , 之后为屏蔽信号创建文件描述符 , 当时机成熟 , 通过 `read()` 系统调用读取未决信号 (主动接收信号)
>
><img src="./assets/image-20230801145321785.png" alt="image-20230801145321785" />
>
>- 使用 `select(...)` 监听文件描述符 (简单介绍 `selelct(...)` 函数怎么使用)
>
><img src="./assets/image-20230801145329694.png" alt="image-20230801145329694" />
>
>- 使用  `select(...)` 处理信号
>
><img src="./assets/image-20230801145336165.png" alt="image-20230801145336165" />

##### ② 编程实验

>[同步方案二参考代码](https://github.com/WONGZEONJYU/Linux_System_Program/tree/main/10.Signal/15/2_Synchronize_select)

###### a.可靠信号 (实时信号)

><img src="./assets/image-20230801145342846.png" alt="image-20230801145342846" />
>
><img src="./assets/image-20230801145348431.png" alt="image-20230801145348431" />
>
><img src="./assets/image-20230801145354625.png" alt="image-20230801145354625" />

###### b. 不可靠信号

><img src="./assets/image-20230801145400418.png" alt="image-20230801145400418" />
>
><img src="./assets/image-20230801145406736.png" alt="image-20230801145406736" />

##### ③ 存在的问题

>- 虽然解决了信号丢失的问题 , 但是实时性不好。由于使用了`select(...)` 机制 , 即便没有信号需要处理 , 也需要等待 `select(...)` 超时 , $\color{red}{任务}$ **$\color{red}{实时性}$** $\color{red}{受到影响}$。
>
><img src="./assets/image-20230801145414945.png" alt="image-20230801145414945" />

##### ④ 思考

>❓是否可以兼顾 **$\color{red}{信号处理}$** 与 **$\color{red}{任务执行}$** 的实时性?

### 2. 异步解决方案 (多任务) 

>- 使用独立任务处理信号 , 程序逻辑在其它任务中执行
>- 即 : 通过 **$\color{red}{多线程}$** 分离信号处理与程序逻辑
>   - 主线程 : 专用于处理信号
>   - 其它线程 : 完成程序功能

#### (1) 问题

>❓信号递达进程后 , 在 **$\color{red}{哪一个执行流}$** 中进行处理?

#### (2) 多线程信号处理

>- 信号的发送目标是 **$\color{red}{进程}$** , 而不是某个特定的线程
>- 发送给进程的信号仅递送给一个线程 ==> 哪一个线程处理？
>- 内核在不会阻塞目标信号的线程中进行随机选择 (那个线程没有屏蔽信号 , 就在哪个线程的执行流执行)
>- 每个线程拥有独立的信号屏蔽掩码

#### (3) 方案

>- 主线程 : 对目标信号设置信号处理的方式
>   - 当信号递达进程时 , 只可能是 **$\color{red}{主线程}$** 进行信号处理
>- 其它线程 : 首先屏蔽所有可能的信号 (简单粗暴) ,之后执行任务代码
>   - 无法接收到信号 , 不具备信号处理能力
>

#### (4) 进程与线程

>**$\color{red}{进程 : 应用程序的一次加载执行 (系统进行资源分配的基本单位)}$**
>
>**$\color{red}{线程 : 进程中的程序执行流}$**
>
>- 一个进程可以存在多个线程 (至少存在一个线程)
>- 每个线程执行不同的任务 (多个线程可并行执行)
>- 同一个进程中的多个线程共享进程的系统资源

##### ① Linux多线程API函数

><img src="./assets/image-20230801145427512.png" alt="image-20230801145427512" />
>
>- 线程标识 : `pthread_t pthread_self(void);`
>   - 获取当前线程的ID标识 (tid)
>- 线程等待 : `int pthread_join(pthread_t thread, void** retval);`
>   - 等待目标线程执行结束
>

##### ② 多线程编程示例

><img src="./assets/image-20230801145436235.png" alt="image-20230801145436235" />

#### (5) 异步方案示例

##### ①主线程

><img src="./assets/image-20230801145442457.png" alt="image-20230801145442457" />

##### ② 任务线程

><img src="./assets/image-20230801145449378.png" alt="image-20230801145449378" />

#### (6) 编程实验 : 多线程信号处理

>[多线程信号处理参考代码](https://github.com/WONGZEONJYU/Linux_System_Program/tree/main/10.Signal/15/3_Synchronize_thread)

##### ①不可靠信号

><img src="./assets/image-20230801145456241.png" alt="image-20230801145456241" />
>
><img src="./assets/image-20230801145501931.png" alt="image-20230801145501931" />

##### ② 可靠信号(实时信号)

><img src="./assets/image-20230801145508243.png" alt="image-20230801145508243" />
>
><img src="./assets/image-20230801145514364.png" alt="image-20230801145514364" />
>
>![image-20230801145521471](./assets/image-20230801145521471.png)

## (四) 信号设计模式小结

>- 多数程序不需要处理信号 , 因此可直接屏蔽信号
>- 需要处理信号的程序 , 重点考虑信号安全性问题
>   - $\color{red}{同步 处理方案,通过设计让}$ **$\color{red}{任务代码}$** $\color{red}{和}$ **$\color{red}{信号处理代码}$** $\color{red}{交替执行}$
>     - 问题 : 信号处理是否及时? 任务执行是否实时?
>   - $\color{red}{异步 处理方案,}$ **$\color{red}{任务代码}$** $\color{red}{与}$ **$\color{red}{信号处理代码}$** $\color{red}{位于 不同执行流}$
>     - 问题 : 将信号安全性问题转换为线程安全性问题 , 因此 , 程序本身是否做到线程安全?
>

