# 十一 ｜十二、信号发送与处理

## (一) 信号的概念及分类

### 1. 问题

>❓按下 ctrl+c 后 , 命令行的前台进程会被终止 , why?

### 2. 什么是信号

>- 信号是一种 **$\color{red}{"软件中断"}$** , 用来处理异步事件
>   - 内核发送信号到某个进程 , 通知进程事件的发生
>   - 事件可能来自硬件 , 可能来自用户输入 , 可能来自程序自身错误 (如除零错误等)
>
> - 信号是一种类型的 $\color{red}{进程间通信方式}$ ( **$\color{SkyBlue}{一个进程向另一个进程发送信号}$** )
>   - A进程发生事件T , 向B进程发送信号 , B进程执行动作响应事件
>   - 进程可以对接收到的 $\color{red}{不同信号}$ 进行 $\color{red}{不同动作响应}$ (信号 , 处理)
>

### 3. 信号的分类

>- 硬件异常
>   - 内核检测到硬件错误 , 发送相应信号给相关进程
>- 终端信号 (用户交互信号)
>   - 在终端输入“特殊字符”等价于向前台进程组发送相应的信号
>- 软件信号
>   - 在软件层面 (进程代码中) 触发的信号 (发送给自身或其它进程)
>

#### (1) 硬件异常信号

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724134116113.png" alt="image-20230724134116113" />

(2) 终端相关信号

>- `SIGINT` ( `ctrl + c` )
>   - 程序终止信号，用于通知前台进程组终止进程
>- `SIGQUIT` ( `ctrl + \` )
>   - 与`SIGINT`类似，进程收到该信号退出时可产生 coredump 文件
>- `SIGTSTP`( `ctrl + z` )
>   - 停止进程的运行 , 进程收到该信号后可以选择处理和忽略
>   - 进程收到该信号后停止运行 (状态发生转换) , 后续可恢复运行状态

#### (3) 软件相关信号

>- 子进程退出 : 父进程收到`SIGCHLD`信号
>- 父进程退出 : 子进程可能收到信号 ( 什么信号? )
>- 定时器到期 : `alarm()` , `ualarm()` , `timer_create()` , ……
>- 主动发送信号 : `kill()` , `raise()` , ……
>- ……

### 4. 内核与信号

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724134602656.png" alt="image-20230724134602656" />

### 5. System V  vs  BSD

>- System V：也被称为 AT&T SystemV，是Unix操作系统众多版本中的一支
>- BSD：加州大学伯克利分校开创，Unix衍生系统，代表由此派生出的各种套件组合
>
>```
>📖 Linux之所以被称为类Unix操作系统,部分原因就是Linux的操作风格是介于上述二者之间,且不同厂商为了照顾不同的用户,其发行版本的操作风格存在差异
>```
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724134745523.png" alt="image-20230724134745523" />

## (二) 信号发送与处理

### 1. 信号处理

#### (1) 信号的默认处理

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724134843703.png" alt="image-20230724134843703" />

#### (2) 自定义信号处理

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724134902389.png" alt="image-20230724134902389" />
>
>```c++
>#include <sys/types.h>
>#include <signal.h>
>typedef void(*sighandler_t)(int);
>sighandler_t signal(int signum, sighandler_t handler);
>sighandler_t sysv_signal(int signum, sighandler_t handler);
>sighandler_t bsd_signal(int signum, sighandler_t handler);
>```

#### (3) 信号处理示例

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724134954717.png" alt="image-20230724134954717" />

### 2. 信号发送

#### (1) 自定义信号发送

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724135036046.png" alt="image-20230724135036046" />
>
>```c++
>#include <sys/types.h>
>#include <signal.h>
>int kill(pid_t pid, int sig); 
>int raise(int sig); // 信号处理完毕后返回 (信号处理函数的每一段代码执行完毕之后才返回)
>```
>
>```
>📖
>标准信号是Unix系统中的信号,编号范围从1到31
>实时信号是Linux独有的信号,编号范围从32到64
>```
>
>- `kill(...)` 和 `raise(...)` 是用来发送信号的 : 
>   - `raise(...)` 把信号发送给 **(进程)** 自身
>   - `kill(...)` 把信号发送给 **进程** 或 **进程组**
>    - `pid > 0` , 将信号传给进程识别码为pid 的进程
>    - `pid == 0` , 将信号传给和目前进程相同进程组的所有进程 ($\color{red}{当前进程组下的所有进程}$ 都会收到信号)
>    - `pid == -1` , 将信号 **$\color{red}{广播}$** 传送给系统内所有的进程
>    - `pid < 0` , 将信号传给 进程组识别码 为 pid绝对值 的所有进程

#### (2) 信号发送示例

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724135456467.png" alt="image-20230724135456467" />

#### (3) 编程实验 : 信号发送与处理

>[信号发送与处理main.cpp参考代码](https://github.com/WONGZEONJYU/Linux_System_Program/blob/main/10.Signal/11/main.cpp)
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724135548971.png" alt="image-20230724135548971" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724135554672.png" alt="image-20230724135554672" />
>
>[main.cpp test.cpp参考代码](https://github.com/WONGZEONJYU/Linux_System_Program/tree/main/10.Signal/11)
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724135752977.png" alt="image-20230724135752977" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724135800125.png" alt="image-20230724135800125" />

## (三) 信号处理三大特性

### 1. 问题

>❓三种注册信号与处理函数的方法有什么区别?

### 2. 信号的OneShot 性

>- System V风格的signal函数 , 注册的 $\color{red}{信号处理是}$ **$\color{red}{一次性的}$**
>   - 进程收到信号后 , 调用由signal注册的处理函数
>   - 处理函数一旦执行之后 , 进程通过默认的方式处理后续相同信号
>   - 如果想要重复触发 , 那么必须再次调用 sys_v风格 的`signal(...)` (`sysv_signal(...)`) 注册处理函数
>- BSD风格的signal函数不存在 OneShot , 能够自动反复触发处理函数的调用
>- 默认的signal函数和BSD风格的signal函数一致
>

### 3. 信号的自身屏蔽特性

>- 在信号处理函数执行期间 (还未处理结束) , $\color{red}{很可能再次收到当前信号 (相同信号)}$
>   - 即 : 处理 A 信号的时候 , 再次收到 A 信号
>
>- 对于 System V 风格的 signal 函数 , $\color{red}{会引起信号处理函数的重入}$
>   - 即 : 调用处理函数的过程中 , 再次收到同个信号触发信号处理函数的调用
>
>
>
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724140701032.png" alt="image-20230724140701032" />
>
>
>
>- 在注册信号处理函数时 : 
>   - System V风格的 `signal()` 不屏蔽任何信号
>   - BSD风格的 `signal()` 会屏蔽当前注册的信号 , 即 : 再次收到同个信号时 , 等待第一次收到的信号的处理函数执行完之后 , 再触发第二次的信号处理函数的调用
>
>
>
>```
>❓思考:BSD风格的signal函数,处理A信号期间,如果收到B信号会发生什么?
>```

### 4.系统调用重启特性

>- 系统调用期间 , 可能收到信号 , $\color{red}{此时进程 必须 从系统调用中}$ **$\color{red}{返回}$**
>- 对于执行时间较长的系统调用 ( `write()` / `read()` ) , 被信号中断的可能性很大
>   - 如果希望信号处理之后 , $\color{red}{被中断的系统调用能够重启}$ , 则 : 
>     - 可以通过条件 `errno == EINTR` 判断 **$\color{red}{手动重启}$** 系统调用
>
>- 系统调用重启示例代码 ( `wait()` ) :
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724141935773.png" alt="image-20230724141935773" />
>
>- 系统调用重启特性 : 
>   - System V 风格的 `signal()` 函数 : ( **$\color{red}{手工重启}$** )
>     - 系统调用被信号中断后 , 直接返回 `-1` , 并且 `errno == EINTR`
>
>   - BSD 风格的 `signal()` 函数 : ( **$\color{red}{自动重启}$** )
>     - 系统调用被中断 , 内核在信号处理函数结束后 , 自动重启系统调用
>

### 5. 默认`signal(...)`函数的特性

>对于大多数的Linux发行版本来说 , $\color{red}{默认}$ `signal()` $\color{red}{函数的行为和BSD风格的}$ `signal()` $\color{red}{函数一致}$

### 6. 编程实验 : 三种特性实验

#### (1) oneshot 实验

>[oneshot 实验, 包含3个cpp文件, 参考代码](https://github.com/WONGZEONJYU/Linux_System_Program/tree/main/10.Signal/12/0_exp/oneshot)
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724143325588.png" alt="image-20230724143325588" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724143333076.png" alt="image-20230724143333076" />

#### (2) 信号的自身屏蔽特性 (信号重入) 实验

>[信号重入,3个cpp文件,参考代码](https://github.com/WONGZEONJYU/Linux_System_Program/tree/main/10.Signal/12/0_exp/signal_reentrant)
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724143615300.png" alt="image-20230724143615300" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724143623505.png" alt="image-20230724143623505" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724143629947.png" alt="image-20230724143629947" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724143641374.png" alt="image-20230724143641374" />

#### (3) 系统调用重启实验

>[系统重启实验 , 包含3个cpp文件, 参考链接](https://github.com/WONGZEONJYU/Linux_System_Program/tree/main/10.Signal/12/0_exp/sys_call_reboot)
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724143746484.png" alt="image-20230724143746484" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724143752746.png" alt="image-20230724143752746" />

#### (4) 处理A信号收到B信号

>❓BSD风格的signal函数 , 处理A信号期间 , 如果收到B信号会发生什么?
>
>[BSD signal 处理A信号收到B信号](https://github.com/WONGZEONJYU/Linux_System_Program/tree/main/10.Signal/12/0_exp/diff_signal)
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724144118947.png" alt="image-20230724144118947" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724144127373.png" alt="image-20230724144127373" />

### 7. 编程实验 : 三种特性实验

>- 并非所有的系统调用对信号中断都表现同样的行为
>   - 一些系统调用支持信号中断后自动重启
>     - `read()` , `write()` , `wait()` , `waitpid()` , `ioctl()` , …
>
>   - 一些系统调用完全不支持信号中断后自动重启
>     - `poll()` , `select()` , `usleep()` , …
>
>
>```tex
>📖 如何知道那些系统调用支持?哪些不支持?在Linux终端输入命令: man 7 signal
>```

### 8. 小结

>- 三种方法的区别 : 
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724144542436.png" alt="image-20230724144542436" />
>
>```
>📖在信号处理上,Linux系统更接近BSD风格的操作;默认的signal函数在不同的Linux发行版上语义可能不同,从代码移植性角度,避免直接使用signal(…)函数
>```

## (四) 初探现代信号处理

### 1. 现代信号处理注册函数

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724144906946.png" alt="image-20230724144906946" />

#### (1) 现代信号处理语义分析

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724144932829.png" alt="image-20230724144932829" />
>
>信号屏蔽与标记 : 
>
>- `sigset_t sa_mask`
>   - 信号屏蔽 : `sa_mask = SIGHUP | SIGINT | SIGUSR1;`
>   - 注意 : 并不是所有信号都可以被屏蔽 , 如 :  `SIGKILL`  , `SIGSTOP`
>- `int sa_flags`
>   - 信号特性 : `sa_flags = SA_ONESHOT | SA_RESTART;`
>   - 特殊特性 ( `SA_SIGINFO` ) , 信号处理时能够收到额外的附加信息
>

#### (2) 信号状态小知识

>- 信号 **$\color{red}{产生}$**
>    - 信号来源,如 : `SI_KERNEL` , `SI_USER` , `SI_TIMER` , …
>- 信号 **$\color{red}{未决}$**
>    - 从信号产生到信号被进程接受的状态 **(处于未决状态的信号必然已存在)**
>- 信号 **$\color{red}{递达}$**
>    - 信号送达进程 , 被进程接收 ( **$\color{red}{忽略 , 默认处理 , 自定义处理}$** )

#### (3) 信号屏蔽 vs 信号阻塞

>- $\color{red}{信号屏蔽}$ ==> 信号未决
>   - 信号处理函数执行期间 , 被屏蔽的信号不会被递送给进程 (针对多个信号)
>   - `act.sa_mask = SIGHUP | SIGINT | SIGUSR1;`
>
>- $\color{red}{信号阻塞}$ ==> 信号未决
>   - 信号处理函数执行期间 , 当前信号不会递送给进程 ( **当前信号** ) , 这个行为也是**默认行为** 
>   - `act.sa_flags = SA_RESTART;` , 或者不设置 `act.sa_flags = 0`
>
>- $\color{red}{信号不阻塞}$ 
>   - 信号处理函数执行期间 , 当前信号会递送给进程 (当前信号) 
>   - `act.sa_flags = SA_RESTART | SA_NODEFER;` , 或 `act.sa_flags = SA_NODEFER;`
>
>```tex
>📖 SA_RESTART标记: 表示当信号处理函数退出后,内核会把 系统调用 自动重启,不需程序员 手动重启
>```
>
>```
>📖 一般情况下,当信号处理函数运行时,内核将阻塞该给定信号。但是如果设置了SA_NODEFER 标记,那么在该信号处理函数运行时,内核将不会阻塞该信号
>```
>
>```
>‼️ ‼️ ‼️ 注意: 如果sa_mask加入了注册信号本身(当前信号),act.sa_flags设置SA_NODEFER标记是无效的
>```
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724150055310.png" alt="image-20230724150055310" />

### 2. 现代信号处理注册示例

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724152139631.png" alt="image-20230724152139631" />

### 3. 编程实验 : 现代信号处理

#### (1) oneshot

>[现代信号处理 , oneshot特性](https://github.com/WONGZEONJYU/Linux_System_Program/blob/main/10.Signal/12/1_exp/oneshot/main.cpp)
>
><h3>1. 设置SA_RESETHAND</h3>
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724152322463.png" alt="image-20230724152322463" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724152333204.png" alt="image-20230724152333204" />
>
><h3>2. 屏蔽SA_RESETHAND</h3>
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724152606451.png" alt="image-20230724152606451" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724152614670.png" alt="image-20230724152614670" />

#### (2) 屏蔽&阻塞相关

>[屏蔽 & 阻塞 , 相关实验参考代码](https://github.com/WONGZEONJYU/Linux_System_Program/blob/main/10.Signal/12/1_exp/mask_block/main.cpp)
>
><h3>1. 设置SA_NODEFER , 取消所有对信号的阻塞和阻塞</h3>
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724152743809.png" alt="image-20230724152743809" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724152751405.png" alt="image-20230724152751405" />
>
><h3>2.取消SA_NODEFER标记 </h3>
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724153137642.png" alt="image-20230724153137642" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724153143773.png" alt="image-20230724153143773" />

#### (3) 系统调用重启

>[系统调用自动重启实验参考代码](https://github.com/WONGZEONJYU/Linux_System_Program/blob/main/10.Signal/12/1_exp/sys_call_reboot/main.cpp)
>
><h3>1.手动重启</h3>
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724153313826.png" alt="image-20230724153313826" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724153357983.png" alt="image-20230724153357983" />
>
><h3>2.自动重启</h3>
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724153428553.png" alt="image-20230724153428553" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724153434840.png" alt="image-20230724153434840" />

#### (4) 处理A收到B

>[正在处理某个信号 , 不同信号的信号递达进程](https://github.com/WONGZEONJYU/Linux_System_Program/tree/main/10.Signal/12/1_exp/deff_signal)
>
><h3>1. sa_mask 加入信号值为40的信号 , 同时 sa_flags 标记 SA_NODEFER</h3>
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724153548946.png" alt="image-20230724153548946" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724153555481.png" alt="image-20230724153555481" />
>
><h3>2. 取消屏蔽信号值为40的信号 , 同时 sa_flags 标记 SA_NODEFER </h3>
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724153932689.png" alt="image-20230724153932689" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724153942938.png" alt="image-20230724153942938" />

#### (5) `signal(...)` 实际调用 `sigaction(...)`

>[main.cpp参考代码链接](https://github.com/WONGZEONJYU/Linux_System_Program/blob/main/10.Signal/11/main.cpp)
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724154244052.png" alt="image-20230724154244052" />

### (五) 现代信号发送与处理

#### 1. `sigqueue(...)`

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724154508248.png" alt="image-20230724154508248" />
>
>- `sigqueue(…)` 的黄金搭档是 `sigaction(…)`
>- `sa_flags` 设置 `SA_SIGINFO` 标志位 , 可使用 **$\color{red}{三参数}$** $\color{red}{信号处理函数}$
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724154526616.png" alt="image-20230724154526616" />

#### 2. 现代信号处理函数的关键参数

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724154700182.png" alt="image-20230724154700182" />
>
>```tex
>‼️ ‼️ ‼️
>si_code成员用于判断到底是谁发来的信号。内核❓还是用户进程❓
>si_value用于附带数据
>```

#### 3. 现代信号发送处理示例

><img src="十一 ｜十二、信号发送与处理.assets/image-20230724154817070.png" alt="image-20230724154817070" />

#### 4. 编程实验 : 现代信号发送

>[现代信号发送,参考代码链接](https://github.com/WONGZEONJYU/Linux_System_Program/tree/main/10.Signal/12/1_exp/sigqueue)
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724154908195.png" alt="image-20230724154908195" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724154914177.png" alt="image-20230724154914177" />
>
><img src="十一 ｜十二、信号发送与处理.assets/image-20230724154919957.png" alt="image-20230724154919957" />

#### 5. 思考

> ❓利用信号搞进程间通信靠谱吗 ? ? ?

