# Linux线程 API 详解

问题 : 一个线程执行后申请了资源 , 中途又不得不提前结束 , 该怎么办 ❓

# 1. 线程清理函数

> ```c++
> #include <pthread.h>
> /*注册清理函数*/
> void pthread_cleanup_push(void (*start_routine) (void*),void* arg);
> /*线程入口函数正常退出的时候,参数决定是否调用清理函数,非0值调用,0值不调用*/
> /*如果线程入口函数中途异常退出( 中途调用了pthread_exit(...)函数 , 参数不起作用 )*/
> void pthread_cleanup_pop( int execute );
> ```

> ```tex
> Linux中这两个函数必须同时出现在同一个作用域中!!!
> 只写一个,会发生编译报错
> 
> ```

* `pthread_cleanup_push` : 
  * 注册线程 "被迫" 结束时 , 需要执行的函数(资源释放可在函数中完成)  
* `pthread_cleanup_pop` : 
  * "弹出" 之前注册的函数 , 根据参数决定是否执行函数
  * "弹出操作" 必须位于 return 语句之前  

## 1.1下面的程序输出什么❓为什么❓

<img src="assets/image-20240109165107065.png" alt="image-20240109165107065" /> 

## 1.2 编程yi

[[test1.cpp参考链接]](https://github.com/WONGZEONJYU/Linux_System_Program/blob/main/1-9-Linux-Thread_API_2/test1.cpp)

> ```c++
> #include <iostream>
> #include <thread>
> #include <cstring>
> 
> using namespace std;
> using namespace chrono;
> using namespace this_thread;
> 
> void clean_test(void* arg)
> {
>     cout << __FUNCTION__ << " : " << reinterpret_cast<long long>(arg) << "\n";
> }
> 
> void foo()
> {
>     cout << __FUNCTION__ << " begin\n";
>     cout << "I'm " << __FUNCTION__ << "\n" << flush;
>     //pthread_exit(nullptr);
>     cout << __FUNCTION__ << " end\n";
> }
> 
> void* thread_entry(void* arg)
> {
>     pthread_cleanup_push(clean_test,reinterpret_cast<void*>(111));
> 
>     foo();
> 
>     pthread_cleanup_pop(0);
> 
>     return nullptr;
> }
> 
> int main(int argc, char const *argv[])
> {
>     pthread_t t{};
>     pthread_create(&t,nullptr,thread_entry,nullptr);
>     pthread_join(t,nullptr);
>     return 0;
> }
> 
> ```

### 1.2.1 结果一

<img src="assets/image-20240109171302393.png" alt="image-20240109171302393" />  

> ```tex
> 正常执行清理函数,请注意pthread_cleanup_pop(...)的参数为0
> ```

### 1.2.1 结果二

> ```tex
> 屏蔽foo()中的pthread_exit(nullptr);
> ```

 <img src="assets/image-20240109171433460.png" alt="image-20240109171433460" /> 

 <img src="assets/image-20240109172042764.png" alt="image-20240109172042764" /> 

> ```tex
> pthread_cleanup_pop(...)的参数为0,线程没有中途退出,不会调用清理函数
> ```

### 1.2.2 结果三

> ```tex
> 仍然是屏蔽foo()中的pthread_exit(nullptr);
> 把pthread_cleanup_pop(...)的参数改为非0值1
> ```

 <img src="assets/image-20240109172118711.png" alt="image-20240109172118711" /> 

<img src="assets/image-20240109172153849.png" alt="image-20240109172153849" /> 