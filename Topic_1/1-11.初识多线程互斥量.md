# 1.抛砖引玉

问题 : 多个线程同时操作一个全局变量 , 会发生什么❓

下面的程序输出什么❓为什么❓

<img src="assets/image-20240111152757116.png" alt="image-20240111152757116" />  <img src="assets/image-20240111152803954.png" alt="image-20240111152803954" /> 

## 1.1 编程实验

[[test1.cpp参考链接]](https://github.com/WONGZEONJYU/Linux_System_Program/blob/main/1-11.mutex/test1.cpp)

> ```c++
> #include <iostream>
> #include <thread>
> 
> using namespace std;
> using namespace chrono;
> using namespace this_thread;
> 
> int g_count {};
> 
> void* thread_entry(void* arg)
> {  
>     (void)arg;
> 
>     for (size_t i {}; i < 10000; i++){
>         ++g_count;
>     }
> 
>     pthread_detach(pthread_self());
> 
>     return nullptr;
> }
> 
> int main(int argc, char const *argv[])
> {
>     for(int r{}; r < 5; r++){
>         pthread_t t {};
>         pthread_create(&t, nullptr, thread_entry, nullptr);
>     }
> 
>     sleep_for(5s);
>     
>     cout << "g_count = " << g_count << "\n";
> 
>     return 0;
> }
> ```

<img src="assets/image-20240111161738110.png" alt="image-20240111161738110" />  

# 2. 什么是原子操作❓

* 这种操作一旦开始 , 就一直执行到结束 , 中途不会被打断
* 原子操作可以是一个步骤 , 也可以是多个步骤的集合
  * 例 : 一行代码 `i = 0` (赋值语句)
  * 例 : 多行代码 `func()` (函数调用)
* 原子操作的顺序不可以被打乱 , 也不可以被切割而只执行其中的一部分
* 原子操作在多 任务/线程 并发时能够保证操作结果的正确性  

思考 : 程序中的 `i++` 是原子操作吗❓

<img src="assets/image-20240111162654375.png" alt="image-20240111162654375" /> 

> ```tex
> i++ 在 C/C++ 语言中不是原子操作,因此在多 任务 / 线程 并发场景中无法保证语义正确性
> ```

 <img src="assets/1.jpg" alt="1" /> 

> ```tex
> 所以,i = 1明显不是我们想要的结果,这个就是由于i++不是原子操作所导致的问题
> ```

* 结论 : 应该避免多个线程同时操作一个全局变量
* 需求 : **$\color{red}{保证操作的原子性}$**
* 临界区 : 
  * 临界区是访问共享资源的代码片段 (共享资源无法同时被访问多线程访问)  
  * 临界区一次仅允许一个线程进入执行 (临界区具有原子性)  
  * 当有线程进入临界区时 , 其它线程必须等待 (线程之间存在竞争关系)  

# 3. 临界区的访问方式

| 非临界区，多个线程可以同时访问 |
| :----------------------------: |
|              LOCK              |
| 临界区，每次最多一个线程可访问 |
|             UNLOCK             |
| 非临界区，多个线程可以同时访问 |

