# 1-1.初探Linux进程调度

## 1. 已知

>**$\color{red}{父进程创建子进程后,父子进程同时运行}$**

## 2. 问题

>❓ 如果计算机 **$\color{red}{只有一个处理器}$** , 父子进程以什么方式同时**$\color{red}{执行}$**?
>
>- 运行 : 从**$\color{red}{可执行文件}$**变成**$\color{red}{进程}$**的过程
>
>- 执行 : 拿到处理器之后 , 执行进程的指令

## 3. Linux系统调度

>- 内核具有进程调度的能力 , 多个进程可同时运行
>- 微观上 , 处理器同一时间只能执行一个进程
>- 同时运行多个进程时,  每个进程都会获得适当的执行时间片
>- 当执行时间片用完 , 内核调度下一个进程执行

## 4. 进程调度原理

>- n 个进程 ( n >= 2 ) 同时位于内存中
>- 处理器执行每个进程 , 每个进程拥有一个时间片
>- 时间片用完 , 通过时钟中断完成进程切换 (调度)
>
>```c++
>void Schedule()
>{
>    gCTaskAddr = &gTaskBuff[index % 4];
>    index++;
>    PrepareForRun(gCTaskAddr);
>    LoadTask(gCTaskAddr);
>}
>```
>
>
