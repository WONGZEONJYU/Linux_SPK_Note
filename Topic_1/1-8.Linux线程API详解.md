# 1. 再论线程创建函数

```c++
int pthread_create (pthread_t* thread,
			   const pthread_attr_t* attr,/*线程属性参数*/
			   void *(*start_routine) (void *),/*线程入口*/
			   void * arg);
```

|  返回值  |                 描述                  |
| :------: | :-----------------------------------: |
|    0     |             线程创建成功              |
| `EAGAIN` |    系统资源不够 或 线程数超出限制     |
| `EINVAL` | 属性参数 `attr` 不合法 (成员值不合法) |
| `EPERM`  | 没有足够的权限设置调度策略和调度参数  |

# 2. 详解线程属性 `pthread_attr_t attr` 参数

```c++
typedef struct /*一种可能的定义*/
{
       int                       detachstate;     //线程的分离状态
       int                       schedpolicy;     //线程调度策略
       struct sched_param        schedparam;      //线程的调度参数
       int                       inheritsched;    //线程的继承性
       int                       scope;           //线程的作用域
       size_t                    guardsize;       //线程栈末尾的警戒缓冲区大小
       int                       stackaddr_set;	  //线程的栈设置
       void *                    stackaddr;       //线程栈的位置
       size_t                    stacksize;       //线程栈的大小
}pthread_attr_t;
```

# 3. 详解线程属性 API 函数

<img src="assets/image-20231125105035101.png" alt="image-20231125105035101" /> 

# 4. 详解线程属性 `pthread_attr_t attr` 参数

<img src="assets/image-20231125111119934.png" alt="image-20231125111119934" /> 

# 5. 线程属性函数示例

<img src="assets/image-20231125111245802.png" alt="image-20231125111245802" /> 

# 6. 编程实验

[[参考链接]](https://github.com/WONGZEONJYU/Linux_System_Program/blob/main/1-8-Linux-Thread_API/test1.cpp)

> ```c++
> //#define _GNU_SOURCE     /* To get pthread_getattr_np() declaration */
> #include <thread>
> #include <iostream>
> #include <cstdlib>
> #include <unistd.h>
> #include <errno.h>
> 
> using namespace std;
> 
> static void print_attr(const char* prefix,const pthread_attr_t* attr)
> {
>     int i {};
>     auto r { pthread_attr_getdetachstate(attr, &i)};
>     cout << (prefix ? prefix : "") << " - Detach state(" << r << ")        = " << ((i == PTHREAD_CREATE_DETACHED) ? "PTHREAD_CREATE_DETACHED" :
>                                                                             (i == PTHREAD_CREATE_JOINABLE) ? "PTHREAD_CREATE_JOINABLE" :"???") << "\n";
> 
>     r = pthread_attr_getscope(attr, &i);
>     cout << (prefix ? prefix : "") << " - Scope(" << r << ")                = " << ((i == PTHREAD_SCOPE_SYSTEM)  ? "PTHREAD_SCOPE_SYSTEM" :
>                                                                                 (i == PTHREAD_SCOPE_PROCESS) ? "PTHREAD_SCOPE_PROCESS" :"???") << "\n";
> 
>     r = pthread_attr_getinheritsched(attr, &i);
>     cout << (prefix ? prefix : "") << " - Inherit scheduler(" << r << ")    = " << ((i == PTHREAD_INHERIT_SCHED)? "PTHREAD_INHERIT_SCHED" :
>                                                                                 (i == PTHREAD_EXPLICIT_SCHED)? "PTHREAD_EXPLICIT_SCHED" :"???") << "\n";
> 
>     r = pthread_attr_getschedpolicy(attr, &i);
>     cout << (prefix ? prefix : "") << " - Scheduling policy(" << r << ")    = " << ((i == SCHED_OTHER) ? "SCHED_OTHER" :
>                                                                                 (i == SCHED_FIFO)  ? "SCHED_FIFO" : 
>                                                                                 (i == SCHED_RR)? "SCHED_RR" :"???") << "\n";
> 
>     sched_param sp {};
>     r = pthread_attr_getschedparam(attr, &sp);
>     cout << (prefix ? prefix : "") << " - Scheduling priority(" << r << ")  = " << sp.sched_priority << "\n";
> 
>     size_t v {};
>     r = pthread_attr_getguardsize(attr, &v);
>     cout << (prefix ? prefix : "") << " - Guard size(" << r << ")          = 0x" << hex << v << " bytes\n";
> 
>     void* stkaddr {};
>     r = pthread_attr_getstack(attr, &stkaddr, &v);
>     cout << (prefix ? prefix : "") << " - Stack address(" << r << ")       = " << stkaddr << "\n";
>     cout << (prefix ? prefix : "") << " - Stack size(" << r << ")          = 0x" << hex << v << " bytes\n\n";
> 
> }
> 
> static void* thread_entry(void*)
> {   
>     cout << "thread: " << pthread_self() << "\n";
> 
>     pthread_attr_t attr{};
>     pthread_getattr_np(pthread_self(), &attr);
>     
>     print_attr("thread", &attr);
>     return {};
> }
> 
> int main(int argc, char const *argv[])
> {
>     pthread_attr_t attr{};
> 
>     pthread_attr_init(&attr);
> 
>     print_attr("init", &attr);
>     
>     //auto r {pthread_attr_setstacksize(&attr, 4 * 1024)}; /*不建议手动设置栈大小*/
>     /*设置4K会出错*/
> 
>     auto r {pthread_attr_setstacksize(&attr, 1024 * 1024)};
> 
>     pthread_t t{};
>     pthread_create(&t, &attr, thread_entry, nullptr);
>     pthread_join(t, nullptr);
> 
>     pthread_getattr_np(pthread_self(), &attr);
>     
>     print_attr("main", &attr);
>     
>     pthread_attr_destroy(&attr);
> 
>     return {};
> }
> 
> ```

<img src="assets/image-20231129134633872.png" alt="image-20231129134633872" /> 
