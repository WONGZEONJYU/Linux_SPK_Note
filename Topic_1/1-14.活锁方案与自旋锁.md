问题 : 如何设置获取互斥量时的等待时间❓如果等待超时 , 如何避免死锁❓

# 1. 避免死锁 -- 设置等待超时

解决方案 : 

1. 尝试获取第 1 个互斥量 : 
   * 若成功 , 则转 2 执行；若失败 , 则等待;

2. 尝试在规定时间内获取第 2 个互斥量 : 

   * 若成功 , 则执行临界区代码  

   * 若失败 , 则释放第 1 个互斥量 , 休眠后转 1 执行  

<img src="assets/image-20240114164919642.png" alt="image-20240114164919642" /> 

# 2. 互斥量获取超时 API 函数

> ```c++
> #include <pthread.h>
> 
> // 尝试获取互斥量
> // 互斥量处于未锁定状态，调用线程对互斥量上锁
> // 互斥量处于锁定状态，调用线程短暂陷入等待状态
> int pthread_mutex_timedlock (pthread_mutex_t* mutexconst struct timespec* tsptr);
> 
> // 解锁互斥量，其它线程可竞争上锁权
> int pthread_mutex_unlock (pthread_mutex_t* mutex);
> 
> #include <time.h>
> struct timespec {
>     time_t tv_sec; /* seconds */
>     long tv_nsec; /* nanoseconds */
> };
> 
> // 获取 clk_id 所指定的时间，获取成功则 tp 保存时间值
> int clock_gettime (clockid_t clk_id, struct timespec* tp);
> 
> ```

# 3."活锁" 解决方案实现

<img src="assets/image-20240114170954431.png" alt="image-20240114170954431" /> 

## 3.1 编程实验

[[test1.cpp参考链接]](https://github.com/WONGZEONJYU/Linux_System_Program/blob/main/1-14.Livelock-and-spinlock/test1.cpp)

> ```c++
> #include <iostream>
> #include <thread>
> 
> using namespace std;
> using namespace chrono;
> using namespace this_thread;
> 
> static pthread_mutex_t m1 (PTHREAD_MUTEX_INITIALIZER);
> static pthread_mutex_t m2 (PTHREAD_MUTEX_INITIALIZER);
> 
> static int g_count {};
> 
> void live_lock(pthread_mutex_t* pm[], const int n)
> {
>     int r = -1;
>     
>     while( r ){
>         for(int i{}; i < n; i++){
>             timespec tout {};
>             clock_gettime(CLOCK_REALTIME, &tout);
>             tout.tv_sec += 1; 
>             r = pthread_mutex_timedlock(pm[i], &tout);
> 
>             if( r ){
>                 for(int j{}; j < i; j++) {
>                     pthread_mutex_unlock(pm[j]);
>                 }
>                 sleep_for(100ms);
>                 break;
>             }
>         }
>     }
> }
> 
> void live_unlock(pthread_mutex_t* pm[], const int n)
> {
>     for (int i {}; i < n; i++){
>         pthread_mutex_unlock(pm[i]);
>     }
> }
> 
> void* thread_1(void* )
> {  
>     pthread_mutex_t* pm[] {&m1, &m2};
>     constexpr auto n {sizeof(pm)/sizeof(*pm)};
> 
>     for(;;){
>         live_lock(pm, n);
> 
>         cout << __FUNCTION__ << " : " << g_count++ << "\n";
>         
>         sleep_for(100us);
> 
>         live_unlock(pm, n);
>     }
>     
>     pthread_detach(pthread_self());
>     
>     return nullptr;
> }
> 
> void* thread_2(void* )
> {  
>     pthread_mutex_t* pm[] {&m2, &m1};
>     constexpr auto n {sizeof(pm)/sizeof(*pm)};
>     
>     for(;;){
>         live_lock(pm, n);
> 
>         cout << __FUNCTION__ << " : " << g_count++ << "\n";
>         
>         sleep_for(100us);
> 
>         live_unlock(pm, n);
>     }
>     
>     pthread_detach(pthread_self());
>     
>     return nullptr;
> }
> 
> int main(int argc, char const *argv[])
> {
>     pthread_t t{};
>     
>     pthread_create(&t, nullptr, thread_1, nullptr);
>     pthread_create(&t, nullptr, thread_2, nullptr);
>     
>     cout << "Hello World!\n";
>     
>     for(;;){
>         sleep_for(1s);
>     }
> 
>     return 0;
> }
> 
> ```

<img src="assets/image-20240114173722901.png" alt="image-20240114173722901" /> 

思考 : 线程获取互斥量失败后究竟发生了什么❓

# 4. Linux中的自旋锁

* 自旋锁也是一种用来保证临界区的原子性的机制
* 自旋锁与互斥量类似 , 在任何时刻 , 最多只能有一个持有者
* 自旋锁与互斥量在内部机制上不同 : 
  * 互斥量 : 
    * 如果已经被其它线程持有 , 则当前线程进入等待状态 (不占用处理器 , 进入等待队列)
  * 自旋锁 : 
    * 如果已经被其它线程持有 , 则当前线程一直循环查看自旋锁是否再次可持有  

