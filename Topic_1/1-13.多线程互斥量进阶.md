问题 : 一个线程多次尝试获取同一个互斥量 , 会发生什么❓

# 1. 不同类型的互斥量

| 类型                               | 意义                                 |
| ---------------------------------- | ------------------------------------ |
| `PTHREAD_MUTEX_NORMAL`             | 默认类型,线程获取互斥量失败将等待    |
| `PTHREAD_MUTEX_RECURSIVE` (递归锁) | 允许同一个线程多次获取同一个互斥量   |
| `PTHREAD_MUTEX_ERRORCHECK`         | 不允许同一个线程多次获取同一个互斥量 |
| `PTHREAD_MUTEX_DEFAULT`            | `PTHREAD_MUTEX_NORMAL`               |

另外 : (历史原因)

> ```c++
> PTHREAD_MUTEX_NORMAL => PTHREAD_MUTEX_TIMED_NP
> PTHREAD_MUTEX_RECURSIVE => PTHREAD_MUTEX_RECURSIVE_NP
> PTHREAD_MUTEX_ERRORCHECK => PTHREAD_MUTEX_ERRORCHECK_NP
> PTHREAD_MUTEX_DEFAULT => PTHREAD_MUTEX_NORMAL
> ```

# 2. Linux上的示例程序

<img src="assets/image-20240114143105389.png" alt="image-20240114143105389" /> 

## 2.1 编程实验

[[test1.cpp参考链接]](https://github.com/WONGZEONJYU/Linux_System_Program/blob/main/1-13.mutex_2/test1.cpp)

> ```c++
> #include <iostream>
> #include <thread>
> 
> using namespace std;
> 
> int main(int argc, char const *argv[])
> {
>     cout << "PTHREAD_MUTEX_NORMAL = " << PTHREAD_MUTEX_NORMAL << "\n" << 
>             "PTHREAD_MUTEX_TIMED_NP = " << PTHREAD_MUTEX_TIMED_NP << "\n" << 
>             "PTHREAD_MUTEX_RECURSIVE = " << PTHREAD_MUTEX_RECURSIVE << "\n" <<
>             "PTHREAD_MUTEX_RECURSIVE_NP = " << PTHREAD_MUTEX_RECURSIVE_NP << "\n" << 
>             "PTHREAD_MUTEX_ERRORCHECK = " << PTHREAD_MUTEX_ERRORCHECK << "\n" << 
>             "PTHREAD_MUTEX_ERRORCHECK_NP = " << PTHREAD_MUTEX_ERRORCHECK_NP << "\n" <<
>             "PTHREAD_MUTEX_DEFAULT = " << PTHREAD_MUTEX_DEFAULT << "\n";
> 
>     return 0;
> }
> ```

<img src="assets/image-20240114145058407.png" alt="image-20240114145058407" /> 

# 3. 死锁的概念

* 等待关系
  * 线程所需资源被其它线程所持有 , 进而必须等待 (无法继续执行)
* 循环等待
  * 当线程之间出现循环等待关系时 , 即 : 发生死锁

<img src="assets/image-20240114145326672.png" alt="image-20240114145326672" /> 

下面的程序有问题吗❓为什么❓

<img src="assets/image-20240114145633933.png" alt="image-20240114145633933" /> 

## 3.1 编程实验

[[test2.cpp参考链接]](https://github.com/WONGZEONJYU/Linux_System_Program/blob/main/1-13.mutex_2/test2.cpp)

> ```c++
> #include <iostream>
> #include <thread>
> 
> using namespace std;
> 
> int main(int argc, char const *argv[])
> {
>     pthread_mutex_t mutex{};
>     pthread_mutexattr_t mattr{};
>     pthread_mutexattr_init(&mattr);
>     pthread_mutex_init(&mutex,&mattr);
> 
>     auto r {pthread_mutex_lock(&mutex)};
>     cout << "r = " << r << "\n";
>     r = pthread_mutex_lock(&mutex);
>     cout << "r = " << r << "\n";
> 
>     cout << "hello world\n";
> 
>     pthread_mutex_unlock(&mutex);
>     pthread_mutex_unlock(&mutex);
> 
>     pthread_mutex_destroy(&mutex);
>     pthread_mutexattr_destroy(&mattr);
> 
>     return 0;
> }
> ```

<img src="assets/image-20240114150311298.png" alt="image-20240114150311298" /> 

# 4. 互斥量的类型设置

> ```c++
> #include <pthread.h>
> pthread_mutexattr_t mattr = {0};
> int pthread_mutexattr_init (pthread_mutexattr_t* mattr);
> int pthread_mutexattr_settype (pthread_mutexattr_t* mattr , int type);
> int pthread_mutexattr_gettype (pthread_mutexattr_t* mattr , int* type);
> int pthread_mutexattr_destroy (pthread_mutexattr_t* mattr);
> ```

## 4.1 不同类型的互斥量示例

<img src="assets/image-20240114150626795.png" alt="image-20240114150626795" />  <img src="assets/image-20240114150634758.png" alt="image-20240114150634758" /> 

